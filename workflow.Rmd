---
title: "MSI"
author: "Miao Yu"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    df_print: paged
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,eval = FALSE)
```

```{r}
# load function for workflow
source('helper.r')
```

# Raw data

## Reference peaks

Peaks from all pixels will be added together as one super pixel for reference peak picking. 

The input is the raw data and the output is the super pixel data with m/z, ccs and intensity as csv file.

```{r}
# set the path to the .d folder
path = 'PATH_TO_RAW.d'
# set the dll/so file path
libpath = './'
# set the output file name
outref = 'refpeak.csv'
# set the coord output file name
outcoord = 'coord.csv'
# accept Bruker's lisence
accept_Bruker_EULA_and_on_Windows_or_Linux = TRUE
# set the pixel batch size to generate super pixel
batch_size <- 100000
# set pixel range
xrange <- c(3400,3900)
yrange <- c(1050,1600)

# This function processes raw mass spectrometry data to generate a reference peak list.
# - path: Path to the raw data (e.g., .d folder).
# - accept_Bruker_EULA_and_on_Windows_or_Linux: Set to TRUE to accept the Bruker EULA.
# - libpath: Path to the Bruker library files.
# - batch_size: The number of frames to process in each batch.
# - outref: The output file for the reference peaks.
# - outcoord: The output file for the coordinates.
# - xrange: The x-range of the region of interest.
# - yrange: The y-range of the region of interest.
getrefpeak(path = path,accept_Bruker_EULA_and_on_Windows_or_Linux = accept_Bruker_EULA_and_on_Windows_or_Linux, batch_size = batch_size, outref = outref, outcoord = outcoord, xrange = xrange,yrange = yrange)
```

## Reference peak picking

This part will be used to find reference peaks across the sample.

### Reference peak picking

Set the parameters for peak picking and perform peak picking on super pixels. The default setting will keep all the local max peaks found in the super pixel. However, most of the peaks with smaller intensity will not be retained in the following filtering analysis and more peaks will use more computational resources for peak picking. In this case, intensity cutoff could be carefully set depending on the sensitivity of the instrument and the mean/median value of all the peaks' intensity could be the first choice.

The input of the function would be the output csv file from previous step and the output will be the reference peaks list with m/z, ccs and intensity as csv file.

```{r}
library(data.table)
dtx <- fread('refpeak.csv')
mz_ppm <- 20
ccs_tolerance <- 0.03
snr <- 3
mz_bins <- 1000
ccs_bins <- 50

# This function performs 2D peak picking.
# - dtx$mz: The m/z values.
# - dtx$ccs: The CCS values.
# - dtx$intensity: The intensity values.
# - mz_ppm: The m/z tolerance in ppm.
# - ccs_tolerance: The CCS tolerance.
# - snr: The signal-to-noise ratio cutoff.
# - mz_bins: The number of m/z bins.
# - ccs_bins: The number of CCS bins.
result <- find_2d_peaks(dtx$mz,dtx$ccs,dtx$intensity,mz_ppm,ccs_tolerance,snr,mz_bins,ccs_bins)
fwrite(result,'ref2d.csv')
# retain peaks larger than mean value of all reference peaks
# sub <- result[result$intensity>mean(result$intensity),]
# fwrite(sub,'ref2d.csv')
```

# Quantitative Peaks List

This part will extract peak intensity on all pixels according to extracted reference peaks from super pixel. User need to select normalization methods such as `tic` or `rms` to normalize data and `tic` is the default value. User also need to set `zero_proportion` to remove the peaks with zero_proportion larger than a certain percentage (95% by default) of all pixels. A low `zero_proportion` will remove ions enriched in a smaller region of interests in the samples.

The input will be the RAW data and reference peaks list from previous step. The output will be normalized data with first column as location and following columns as intensitys for each reference peaks.

```{r}
# load the reference peaks
refpath = 'ref2d.csv'
# change to libtimsdata.dll for windows
lib_path <- paste0(libpath,"libtimsdata.so")
# load the raw data
path = 'PATH_TO_RAW.d'
# set normalization method tic or rms
method = 'tic'
# set zero_proportion to remove the peaks with zero_proportion larger than 95%
zero_proportion_cutoff = 0.95
# set the coord file path
coordpath = 'coord.csv'
# set the output file name
normpath = 'ticmzccs.csv'
# set pixel range
xrange <- c(3400,3900)
yrange <- c(1050,1600)
# set the uncertainty of mz and ccs
mz_ppm <- 20
ccs_tolerance <- 0.03
# This function generates a quantitative peak list.
# - refpath: Path to the reference peaks file.
# - lib_path: Path to the Bruker library files.
# - path: Path to the raw data.
# - method: The normalization method ('tic' or 'rms').
# - zero_proportion_cutoff: The cutoff for removing peaks with a high proportion of zeros.
# - coordpath: Path to the coordinates file.
# - normpath: The output file for the normalized peak list.
# - xrange: The x-range of the region of interest.
# - yrange: The y-range of the region of interest.
# - mz_ppm: The m/z tolerance in ppm.
# - ccs_tolerance: The CCS tolerance.
getqlist(refpath = refpath,lib_path = lib_path, path = path, method = method, zero_proportion_cutoff = zero_proportion_cutoff, coordpath = coordpath, normpath = normpath, xrange = xrange, yrange = yrange, mz_ppm = mz_ppm, ccs_tolerance = ccs_tolerance)
```

# Qualitative Peaks List

Qualitative analysis is performed with public available data for MS1-CCS database.

The input will be database csv files (provided as csv file), peaks list from previous step and the output of this step with be a csv file with annotation from the database.

## Lipid annotation

```{r}
# load database
database = 'lipidall.csv'
mode = 'pos'
peakpath = 'ticmzccs.csv'
annofile = 'annoccs.csv'

# This function annotates peaks against a lipid database.
# - database: Path to the lipid database.
# - mode: The ionization mode ('pos' or 'neg').
# - peakpath: Path to the peak list file.
# - annofile: The output file for the annotations.
getanno(database = database,mode = mode, peakpath = peakpath, annofile = annofile)
```

## Metabolites annotation

```{r}
# load database
database = 'metaall.csv'
mode = 'pos'
peakpath = 'ticmzccs.csv'
annofile = 'metaannoccs.csv'

# This function annotates peaks against a metabolite database.
# - database: Path to the metabolite database.
# - mode: The ionization mode ('pos' or 'neg').
# - peakpath: Path to the peak list file.
# - annofile: The output file for the annotations.
getanno(database = database,mode = mode, peakpath = peakpath, annofile = annofile)
```

## mzccsanno Shiny application

You could also use a Shiny application to make annotation with GUI.

```{r}
rmwf::runmzccsanno()
```

# Exploratory Analysis

## Data Summary

This section provides a verbose summary of the processed peak data csv file.

```{r}
# This function reads the peak file and prints a summary of its contents,
# including the number of pixels, number of features, and the ranges for
# m/z, ion mobility (CCS), and spatial coordinates.
# - "ticmzccs.csv": The path to the input peak file.
getsummary("ticmzccs.csv")
```

## Peak statistics

This part will show the distribution of peak numbers.

```{r}
# This function generates and displays plots for peak statistics.
# - "ticmzccs.csv": The path to the input peak file.
plot_peak_stats("ticmzccs.csv")
```

## Visualization

Save selected or all ion images for all reference peaks.

```{r}
# Define a vector of m/z values for which to generate ion images.
mzdemo <- c(703.5732,725.5543,739.4657,760.5806,788.6030,798.5397,826.5585)

# This function saves ion images for the specified m/z values.
# - "ticmzccs.csv": The input peak file.
# - mzdemo: A vector of m/z values.
save_ion_images("ticmzccs.csv", mzdemo)
```

## Segmentation

Segmentation can find region of interests in MSI data.

### PCA segmentation

This part will use PCA to perform segmentation.

```{r}
# This function performs PCA segmentation on the peak data.
# - "ticmzccs.csv": The input peak file.
# - "segmentation.csv": The output file for the segmentation results.
perform_pca_segmentation("ticmzccs.csv", "segmentation.csv")
```

### UMAP segmentation

This part will use UMAP to perform segmentation.

```{r}
# This function performs UMAP segmentation on the peak data.
# - "ticmzccs.csv": The input peak file.
# - "segmentation.csv": The output file for the segmentation results.
perform_umap_segmentation("ticmzccs.csv", "segmentation.csv")
```

## Ion cluster

This part will use cosine/correlation similarity to find ion clusters with similar spatial distribution.

```{r}
# This function clusters ions based on their spatial distribution.
# - "ticmzccs.csv": The input peak file.
# - "ioncluster.csv": The output file for the ion clusters.
# - hclust_cutoff: the cutoff of hierarchical clustering dendrogram
# - min_cluster_size: screen the cluster with a minimum number of ions
cluster_ions("ticmzccs.csv", "ioncluster.csv", hclust_cutoff = 0.6, min_cluster_size = 10)
```

###  ROI specific Ion cluster for ions in certain segmentation

```{r}
# This function clusters ions within a specific region of interest (ROI). This function will generate images for each clusters to help the user find the optimized cutoff.
# - "ticmzccs.csv": The input peak file.
# - "segmentation.csv": The segmentation file.
# - "roi_ion_cluster.csv": The output file for the ROI ion clusters.
# - roi_cluster: ROI cluster number.
# - hclust_cutoff: the cutoff of hierarchical clustering dendrogram
# - min_cluster_size: minium number of ions in the cluster
cluster_roi_ions("ticmzccs.csv", "segmentation.csv", "roi_ion_cluster.csv", roi_cluster = 2, hclust_cutoff = 0.8, min_cluster_size = 10)
```

## Reactomics analysis

This part will extract PMDs for reaction level check.

The input is the peak list csv file and the output is the reaction level csv files

```{r}
# This function performs reactomics analysis.
# - "ticmzccs.csv": The input peak file.
# - "reactomics.csv": The output file for the reactomics analysis.
perform_reactomics_analysis("ticmzccs.csv", "reactomics.csv")
```

###  ROI specific reactomics analysis for ions in certain segmentation

```{r}
# This function clusters ions within a specific region of interest (ROI). This function will generate images for each clusters to help the user find the optimized cutoff.
# - "ticmzccs.csv": The input peak file.
# - "segmentation.csv": The segmentation file.
# - "reactomics.csv": The output file for the reactomics analysis.
# - roi_cluster: ROI cluster number.
perform_roi_reactomics_analysis("ticmzccs.csv", "segmentation.csv", "roireactomics.csv", roi_cluster = 2)
```

## Molecular Network

This part will generate network figure.

The input is peak list csv file and annotation csv file, and the output is csv file for network generation.

```{r}
# This function generates a molecular network.
# - "ticmzccs.csv": The input peak csv file from quantitative peaks list.
# - "annoccs.csv": The annotation csv file from qualitative peaks list.
# - "molecular_network.csv": The output file for the molecular network.
generate_molecular_network("ticmzccs.csv", "annoccs.csv", "molecular_network.csv")
```

### MSInet Shiny application

Please run the following chunk to get the network csv file for MSInet shiny application.

```{r}
library(pmd)
library(data.table)
dt <- fread("ticmzccs.csv",header = T)

# m/z and im
mz <- sapply(strsplit(colnames(dt)[-1],'_'),function(x) round(as.numeric(x[1]),4))
im <- sapply(strsplit(colnames(dt)[-1],'_'),function(x) as.numeric(x[2]))

# ions
ioncluster <- fread('ioncluster.csv')
library(pmd)
data("sda")
hfpmd <- round(sda$PMD,3)
df <- rmwf::getpmddf2(dt,group = ioncluster$class,pmd=hfpmd,digits = 3)
fwrite(df,'msinet.csv')
```

Please run the following chunk to get figures for ions.

```{r}
dir.create('fig')
ions <- unique(c(df$from,df$to))
mz <- sapply(strsplit(colnames(dt_values),'_'),function(x) round(as.numeric(x[1]),4))
im <- sapply(strsplit(colnames(dt_values),'_'),function(x) as.numeric(x[2]))
name <- paste0(mz,'_',round(im))
dt_values <- as.data.frame(dt_values)
sub <- dt_values[,match(ions,name)]
colnames(sub) <- ions
x <- sapply(strsplit(dt$location,'_'),function(x) as.numeric(x[1]))
y <- sapply(strsplit(dt$location,'_'),function(x) as.numeric(x[2]))
width=max(x)-min(x)+1
height=max(y)-min(y)+1
for(i in 1:ncol(sub)){
  dfx <- sub[,i]
  norm <- (dfx - min(dfx)) / (max(dfx) - min(dfx))
  library(RColorBrewer)
  color_palette <- colorRamp(c("skyblue", "red"))
  color_sequence <- rgb(color_palette(norm)/255,alpha=1)
  png(paste0('fig/',colnames(sub)[i],'.png'),width = width, height = height)
  plot.new()
  par(mar=c(0,0,0,0))
  plot.window(xlim = c(0,width), ylim = c(0,height), xaxs = "i", yaxs = "i", asp = NA)
  points(x-min(x)+1, y-min(y)+1, pch = 16, col = color_sequence,cex=0.3)
  dev.off()
}
```

You can start the shiny app by the following code:

```{r}
rmwf::runmsinet()
```

Then you could update network file (msinet.csv), annotation file (annoccs.csv) and images to generate network visualization for biological people.

```{r}
sessionInfo()
```