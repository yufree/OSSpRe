---
title: "MSI"
author: "Miao Yu"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    df_print: paged
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,eval = FALSE)
```

```{r}
# load function for workflow
source('helper.r')
```

# Raw data

## Reference peaks

Peaks from all pixels will be added together as one super pixel for reference peak picking.

```{r}
# set the path to the .d folder
path = 'PATH_TO_RAW.d'
# set the dll/so file
libpath = './'
# set the output file name
outref = 'refpeak.csv'
# set the coord output file name
outcoord = 'coord.csv'
# accept Bruker's lisence
accept_Bruker_EULA_and_on_Windows_or_Linux = TRUE
# set the pixel batch size to generate super pixel
batch_size <- 100000
# set pixel range
xrange <- c(3400,3900)
yrange <- c(1050,1600)
getrefpeak(path = path,accept_Bruker_EULA_and_on_Windows_or_Linux = accept_Bruker_EULA_and_on_Windows_or_Linux, batch_size = batch_size, outref = outref, outcoord = outcoord, xrange = xrange,yrange = yrange)
```

## Reference peak picking

This part will be used to find reference peaks across the sample.

### Reference peak picking

Set the parameters for peak picking and perform peak picking on super pixels. The default setting will keep all the local max peaks found in the super pixel. However, most of the peaks with smaller intensity will not be retained in the following filtering analysis and more peaks will use more computational resources for peak picking. In this case, intensity cutoff could be carefully set depending on the sensitivity of the instrument and the mean/median value of all the peaks' intensity could be the first choice.

```{r}
library(data.table)
dtx <- fread('refpeak.csv')
mz_ppm <- 20
ccs_tolerance <- 0.03
snr <- 3
mz_bins <- 1000
ccs_bins <- 50
result <- find_2d_peaks(dtx$mz,dtx$ccs,dtx$intensity,mz_ppm,ccs_tolerance,snr,mz_bins,ccs_bins)
fwrite(result,'ref2d.csv')
# retain peaks larger than mean value of all reference peaks
# sub <- result[result$intensity>mean(result$intensity),]
# fwrite(sub,'ref2d.csv')
```

# Quantitative Peaks List

This part will extract peak intensity on all pixels according to extracted reference peaks from super pixel.

```{r}
# load the reference peaks
refpath = 'ref2d.csv'
# change to libtimsdata.dll for windows
lib_path <- paste0(libpath,"libtimsdata.so")
# load the raw data
path = 'PATH_TO_RAW.d'
# set normalization method tic or rms
method = 'tic'
# set zero_proportion to remove the peaks with zero_proportion larger than 95%
zero_proportion_cutoff = 0.95
# set the coord file path
coordpath = 'coord.csv'
# set the output file name
normpath = 'ticmzccs.csv'
# run the function to get Quantitative Peaks List
getqlist(refpath = refpath,lib_path = lib_path, path = path, method = method, zero_proportion_cutoff = zero_proportion_cutoff, coordpath = coordpath, normpath = normpath)
```

# Qualitative Peaks List

Qualitative analysis is performed with public available data for MS1-CCS database.

## Lipid annotation

```{r}
# load database
database = 'lipidall.csv'
mode = 'pos'
peakpath = 'ticmzccs.csv'
annofile = 'annoccs.csv'
getanno(database = database,mode = mode, peakpath = peakpath, annofile = annofile)
```

## Metabolites annotation

```{r}
# load database
database = 'metaall.csv'
mode = 'pos'
peakpath = 'ticmzccs.csv'
annofile = 'metaannoccs.csv'
getanno(database = database,mode = mode, peakpath = peakpath, annofile = annofile)
```

## mzccsanno Shiny application

You could also use a Shiny application to make annotation with GUI.

```{r}
rmwf::runmzccsanno()
```

# Exploratory Analysis

## Peak statistics

This part will show the distribution of peak numbers.

```{r}
dt <- fread("ticmzccs.csv",header = T)
dt[, np := rowSums(.SD != 0)]
# extract location
x <- sapply(strsplit(dt$location,'\\_'),function(x) as.numeric(x[1]))
y <- sapply(strsplit(dt$location,'\\_'),function(x) as.numeric(x[2]))

df <- cbind.data.frame(x=x,y=y,np=dt$np)

library(ggplot2)
ggplot(df,aes(np)) +
  ggtitle('peak number for each pixel')+xlab('peak number')+
  geom_histogram(binwidth=1)+theme_bw()
ggplot(df, aes(x,y)) +
  geom_point(aes(color = np), size = 0.001)+
  scale_color_gradient(low = "white", high = "red") + theme_void()
```

## Visualization

Save selected or all ion images for all reference peaks.

```{r}
library(data.table)
dt <- fread("ticmzccs.csv",header = T)
dt_values <- dt[, -1, with = FALSE]

# location
x <- sapply(strsplit(dt$location,'\\_'),function(x) as.numeric(x[1]))
y <- sapply(strsplit(dt$location,'\\_'),function(x) as.numeric(x[2]))

# m/z and im
mz <- sapply(strsplit(colnames(dt)[-1],'\\_'),function(x) round(as.numeric(x[1]),4))
im <- sapply(strsplit(colnames(dt)[-1],'\\_'),function(x) as.numeric(x[2]))

mzdemo <- c(703.5732,725.5543,739.4657,760.5806,788.6030,798.5397,826.5585)
dt_filtered <- as.data.frame(dt_values[, .SD, .SDcols = mz%in%mzdemo])

width=max(x)-min(x)+1
height=max(y)-min(y)+1 
# save images for all selected ions
for(i in 1:ncol(dt_filtered)){
  dfx <- dt_filtered[,i]
  norm <- (dfx - min(dfx)) / (max(dfx) - min(dfx))
  png(paste0(colnames(dt_filtered)[i],'.png'),width = width, height = height)
  plot.new()
  par(mar=c(0,0,0,0))
  plot.window(xlim = c(0,width), ylim = c(0,height), xaxs = "i", yaxs = "i", asp = NA)
  points(x-min(x)+1, y-min(y)+1, pch = 16, col = grDevices::gray(1 - norm),cex=0.3)
  dev.off()
}
```

## Segmentation

Segmentation can find region of interests in MSI data.

### PCA segmentation

This part will use PCA to perform segmentation.

```{r}
library(data.table)
dt <- fread("ticmzccs.csv",header = T)
dt_values <- dt[, -1, with = FALSE]

# location
x <- sapply(strsplit(dt$location,'\\_'),function(x) as.numeric(x[1]))
y <- sapply(strsplit(dt$location,'\\_'),function(x) as.numeric(x[2]))

# m/z and im
mz <- sapply(strsplit(colnames(dt)[-1],'\\_'),function(x) round(as.numeric(x[1]),4))
im <- sapply(strsplit(colnames(dt)[-1],'\\_'),function(x) as.numeric(x[2]))

mat <- t(dt_values)
# SVD analysis
library(irlba)
svd_result <- irlba(t(mat), nv = 20)
pca_scores <- t(mat) %*% svd_result$v
# variance explained
singular_values <- svd_result$d
explained_variance <- singular_values^2 / sum(singular_values^2)
# find the optimized cluster number
library(ClusterR)
opt = Optimal_Clusters_KMeans(as.data.frame(pca_scores[sample(c(1:ncol(mat)),10000),]), max_clusters = 10, plot_clusters = T, criterion = 'silhouette',initializer = 'optimal_init', tol_optimal_init = 0.2)
# use the optimized number or self-defined number for cluster numbers
km = KMeans_arma(as.matrix(pca_scores), clusters = 5, n_iter = 10, seed_mode = "random_subset", verbose = T, CENTROIDS = NULL)
pr = predict_KMeans(as.matrix(pca_scores), km)
# show the segmentation
plot(pca_scores[,1],pca_scores[,2],col=pr,pch=13,cex=0.1,xlab = 'PC_1',ylab='PC_2')
plot(x,y,col=pr,cex=0.001,pch=19)
legend('topright',legend = unique(pr),col=unique(pr),pch=19,cex=1)
```

### UMAP segmentation

This part will use UMAP to perform segmentation.

```{r}
library(data.table)
dt <- fread("ticmzccs.csv",header = T)
dt_values <- dt[, -1, with = FALSE]

# location
x <- sapply(strsplit(dt$location,'\\_'),function(x) as.numeric(x[1]))
y <- sapply(strsplit(dt$location,'\\_'),function(x) as.numeric(x[2]))

# m/z and im
mz <- sapply(strsplit(colnames(dt)[-1],'\\_'),function(x) round(as.numeric(x[1]),4))
im <- sapply(strsplit(colnames(dt)[-1],'\\_'),function(x) as.numeric(x[2]))

mat <- t(dt_values)
# reticulate::install_miniconda()
Sys.setenv(NUMBA_NUM_THREADS = 30)
library(reticulate)
py_run_string("import os; print(os.environ['NUMBA_NUM_THREADS'])")
library(umap)
# reticulate::py_install('umap-learn')
viz <- umap::umap(t(mat),method = 'umap-learn',metric = 'cosine')
# 5min
library(dbscan)
dbscan_result <- dbscan(viz$layout, eps = 0.1, minPts = 5)
plot(x=x,y=y,col=dbscan_result$cluster,pch=13,cex=0.1,xlab='UMAP_1',ylab='UMAP_2')
plot(viz$layout[,1],viz$layout[,2],col=dbscan_result$cluster,pch=13,cex=0.1)
```

This part will save segmentation results as csv file with pixel locations.

```{r}
seg <- cbind.data.frame(x=x,y=y,pca=pr,umap=dbscan_result$cluster)
fwrite(seg,'segmentation.csv')
```

## Ion cluster

This part will use cosin/correlation similarity to find ion clusters with similar spatial distribution.

```{r}
library(data.table)
dt <- fread("ticmzccs.csv",header = T)
dt_values <- dt[, -1, with = FALSE]

# m/z and im
mz <- sapply(strsplit(colnames(dt)[-1],'\\_'),function(x) round(as.numeric(x[1]),4))
im <- sapply(strsplit(colnames(dt)[-1],'\\_'),function(x) as.numeric(x[2]))

# segmentation
seg <- fread('segmentation.csv',header=T)
# cosin similarity
Matrix <- t(dt_values)
row_norms <- sqrt(rowSums(Matrix^2))
sim <- sweep(Matrix, 1, row_norms, "/")
sim <- sim %*% t(sim)
# correlation distance
# n <- ncol(Matrix)
# Matrix_scaled <- scale(Matrix)
# sim <- (Matrix_scaled %*% t(Matrix_scaled)) / (n - 1)

# change to distance
D_sim <- as.dist(1 - sim)

t <- hclust(D_sim)
# set cutoff
s <- cutree(t,h = 0.6)
# output ion class
ioncluster <- cbind.data.frame(mz,im,class=s)
fwrite(ioncluster,'ioncluster.csv')
```

###  ROI specific Ion cluster for ions in certain segmentation

```{r}
library(data.table)
dt <- fread("ticmzccs.csv",header = T)
dt_values <- dt[, -1, with = FALSE]

# m/z and im
mz <- sapply(strsplit(colnames(dt)[-1],'\\_'),function(x) round(as.numeric(x[1]),4))
im <- sapply(strsplit(colnames(dt)[-1],'\\_'),function(x) as.numeric(x[2]))

# segmentation
seg <- fread('segmentation.csv',header=T)

subdt <- dt_values[seg$umap==2,]
x <- seg$x
y <- seg$y

Matrix <- t(subdt)

# correlation distance
n <- ncol(Matrix)
Matrix_scaled <- scale(Matrix)
sim <- (Matrix_scaled %*% t(Matrix_scaled)) / (n - 1)
D_sim <- as.dist(1 - sim)
# D_sim <- as.dist(1 - sim^2)

# cosine distance
# row_norms <- sqrt(rowSums(Matrix^2))
# sim <- sweep(Matrix, 1, row_norms, "/")
# sim <- sim %*% t(sim)
# # change to distance
# D_sim <- as.dist(1 - sim)

t <- hclust(D_sim)
# set cutoff
s <- cutree(t,h = 0.8)
# only find the clusters with more than 10 ions
name <- as.numeric(names(table(s)[table(s)>10]))

Matrix <- t(dt_values)
split_matrices <- lapply(name, function(category) {
  rows <- which(s == as.numeric(category))
  subset_matrix <- Matrix[rows, , drop = FALSE]
  return(subset_matrix)
})
# sum the intensity from the same clusters
summed_matrices <- lapply(split_matrices, function(subset_matrix) {
  xxx <- apply(subset_matrix, 1, scale)
  x <- rowSums(xxx)/ncol(xxx)
  return(x)
})

# generate figures for cluster TIC maps
result_matrix <- do.call(cbind, summed_matrices)

clpan <- cbind.data.frame(x=x,y=y,result_matrix)

dir.create('cluster')
for(i in c(1:length(name))){
  dfx <- result_matrix[,i]
  norm <- (dfx - min(dfx)) / (max(dfx) - min(dfx))
  color_palette <- colorRamp(c("yellow", "red"))
  color_sequence <- rgb(color_palette(norm)/255,alpha=1)
  xlim=max(x)-min(x)+1
  ylim=max(y)-min(y)+1

  png(paste0('cluster/cluster',name[i],'.png'),width=xlim,height = ylim)
  plot.new()
  par(mar=c(0,0,0,0))
  plot.window(xlim = c(0,xlim), ylim = c(0,ylim), xaxs = "i", yaxs = "i", asp = NA)
  points(x-min(x)+1, y-min(y)+1, pch = 16, col = color_sequence,cex=0.3)
  dev.off()
}

rows <- which(s==390)
result_matrix <- Matrix[rows, , drop = FALSE]
for(i in c(1:nrow(result_matrix))){
  dfx <- result_matrix[i,]
  norm <- (dfx - min(dfx)) / (max(dfx) - min(dfx))
  color_palette <- colorRamp(c("yellow", "red"))
  color_sequence <- rgb(color_palette(norm)/255,alpha=1)
  xlim=max(x)-min(x)+1
  ylim=max(y)-min(y)+1 
  png(paste0('cluster/ion',colnames(dt_values)[rows[i]],'.png'),width=xlim,height = ylim)
  plot.new()
  par(mar=c(0,0,0,0))
  plot.window(xlim = c(0,xlim), ylim = c(0,ylim), xaxs = "i", yaxs = "i", asp = NA)
  points(x-min(x)+1, y-min(y)+1, pch = 16, col = color_sequence,cex=0.3)
  dev.off()
}

islet <- rownames(Matrix)[s==390]
ions <- Matrix[s==390,]
factor <- ifelse(seg$umap==2,'islet','non-islet')
re <- apply(ions,1,function(x) median(x[seg$umap==2])>median(x))
mz <- sapply(strsplit(islet[re],'\\_'),function(x) round(as.numeric(x[1]),4))
im <- sapply(strsplit(islet[re],'\\_'),function(x) as.numeric(x[2]))
isletdf <- cbind.data.frame(mz,im,islet=islet[re])
write.csv(isletdf,'isletcheckall.csv')
```


## Reactomics analysis

This part will extract PMDs for reaction level check.

```{r}
library(pmd)
library(data.table)
dt <- fread("ticmzccs.csv",header = T)
dt_values <- dt[, -1, with = FALSE]

# m/z and im
mz <- sapply(strsplit(colnames(dt)[-1],'\\_'),function(x) round(as.numeric(x[1]),4))
im <- sapply(strsplit(colnames(dt)[-1],'\\_'),function(x) as.numeric(x[2]))

# islet ions
seg <- fread('segmentation.csv',header=T)
isletdf <- fread('isletcheckall.csv',header=T)
df <- getpmddf(mz,pmd=c(14.015,14.016,15.995,15.996,2.015,2.016,18.010,18.011),digits = 3,group = ifelse(colnames(dt)[-1]%in%isletdf$`islet`,1,0))
xy <- data.frame(x=x,y=y)
xy$factor <- seg$umap
# pick up ions from four common PMDs
df$diff3 <- round(df$diff,3)
df3 <- df[df$diff3==14.015|df$diff3==14.016,]
df4 <- df[df$diff3==15.995|df$diff3==15.996,]
df5 <- df[df$diff3==2.015|df$diff3==2.016,]
df6 <- df[df$diff3==18.010|df$diff3==18.011,]
# normalize ion intensity
dfall <- apply(dt_values,1,function(x) x/max(x))
dfall[is.na(dfall)] <- 0
dfall <- t(dfall)
# PMD14.016
dfms1 <- dfall[,mz%in%df3$ms1]
dfms2 <- dfall[,mz%in%df3$ms2]
xy$pmd14h <- apply(dfms1, 1, sum)
xy$pmd14l <- apply(dfms2, 1, sum)
# PMD15.995
dfms1 <- dfall[,mz%in%df4$ms1]
dfms2 <- dfall[,mz%in%df4$ms2]
xy$pmd16h <- apply(dfms1, 1, sum)
xy$pmd16l <- apply(dfms2, 1, sum)
# PMD2.016
dfms1 <- dfall[,mz%in%df5$ms1]
dfms2 <- dfall[,mz%in%df5$ms2]
xy$pmd2h <- apply(dfms1, 1, sum)
xy$pmd2l <- apply(dfms2, 1, sum)
# PMD18.011
dfms1 <- dfall[,mz%in%df6$ms1]
dfms2 <- dfall[,mz%in%df6$ms2]
xy$pmd18h <- apply(dfms1, 1, sum)
xy$pmd18l <- apply(dfms2, 1, sum)
# combine ion pairs
xy$pmd2 <- xy$pmd2h+xy$pmd2l
xy$pmd14 <- xy$pmd14h+xy$pmd14l
xy$pmd16 <- xy$pmd16h+xy$pmd16l
xy$pmd18 <- xy$pmd18h+xy$pmd18l

# check reaction level changes by linear regression
summary(lm(xy$pmd2~xy$factor))
summary(lm(xy$pmd14~xy$factor))
summary(lm(xy$pmd16~xy$factor))
summary(lm(xy$pmd18~xy$factor))

summary(lm(xy$pmd2h~xy$factor))
summary(lm(xy$pmd14h~xy$factor))
summary(lm(xy$pmd16h~xy$factor))
summary(lm(xy$pmd18h~xy$factor))

summary(lm(xy$pmd2l~xy$factor))
summary(lm(xy$pmd14l~xy$factor))
summary(lm(xy$pmd16l~xy$factor))
summary(lm(xy$pmd18l~xy$factor))

# check reaction level changes by t test
anova(lm(xy$pmd2~xy$factor))
anova(lm(xy$pmd14~xy$factor))
anova(lm(xy$pmd16~xy$factor))
anova(lm(xy$pmd18~xy$factor))

```

This part will be used to check if there were spatial changes for certain reaction.

```{r}
library(patchwork)
library(ggplot2)
a <- ggplot(xy, aes(x,y)) +
  geom_point(aes(color = pmd2l), size = 0.001)+ggtitle('PMD 2.02Da low')+
  scale_color_gradient(low = "white", high = "red") + theme_void()
b <- ggplot(xy, aes(x,y)) +
  geom_point(aes(color = pmd2h), size = 0.001)+ggtitle('PMD 2.02Da high')+
  scale_color_gradient(low = "white", high = "red") + theme_void()
c <- ggplot(xy, aes(x,y)) +
  geom_point(aes(color = pmd14l), size = 0.001)+ggtitle('PMD 14.02Da low')+
  scale_color_gradient(low = "white", high = "red") + theme_void()
d <- ggplot(xy, aes(x,y)) +
  geom_point(aes(color = pmd14h), size = 0.001)+ggtitle('PMD 14.02Da high')+
  scale_color_gradient(low = "white", high = "red") + theme_void()
e <- ggplot(xy, aes(x,y)) +
  geom_point(aes(color = pmd16l), size = 0.001)+ggtitle('PMD 16.00Da low')+
  scale_color_gradient(low = "white", high = "red") + theme_void()
f <- ggplot(xy, aes(x,y)) +
  geom_point(aes(color = pmd16h), size = 0.001)+ggtitle('PMD 16.00Da high')+
  scale_color_gradient(low = "white", high = "red") + theme_void()
g <- ggplot(xy, aes(x,y)) +
  geom_point(aes(color = pmd18l), size = 0.001)+ggtitle('PMD 18.01Da low')+
  scale_color_gradient(low = "white", high = "red") + theme_void()
h <- ggplot(xy, aes(x,y)) +
  geom_point(aes(color = pmd18h), size = 0.001)+ggtitle('PMD 18.01Da high')+
  scale_color_gradient(low = "white", high = "red") + theme_void()
a|b
c|d
e|f
g|h
```

This part will be used to check locations for certain reaction.

```{r}
library(patchwork)
library(ggplot2)
a <- ggplot(xy, aes(x,y)) +
  geom_point(aes(color = pmd2), size = 0.001)+ggtitle('PMD 2.02Da')+
  scale_color_gradient(low = "white", high = "red") + theme_void()
b <- ggplot(xy, aes(x,y)) +
  geom_point(aes(color = pmd14), size = 0.001)+ggtitle('PMD 14.02Da')+
  scale_color_gradient(low = "white", high = "red") + theme_void()
c <- ggplot(xy, aes(x,y)) +
  geom_point(aes(color = pmd16), size = 0.001)+ggtitle('PMD 16.00Da')+
  scale_color_gradient(low = "white", high = "red") + theme_void()
d <- ggplot(xy, aes(x,y)) +
  geom_point(aes(color = pmd18), size = 0.001)+ggtitle('PMD 18.01Da')+
  scale_color_gradient(low = "white", high = "red") + theme_void()
a|b|c|d
```

## Molecular Network

```{r}
library(pmd)
library(data.table)
dt <- fread("ticmzccs.csv",header = T)
dt_values <- dt[, -1, with = FALSE]

# m/z and im
mz <- sapply(strsplit(colnames(dt)[-1],'\\_'),function(x) round(as.numeric(x[1]),4))
im <- sapply(strsplit(colnames(dt)[-1],'\\_'),function(x) as.numeric(x[2]))

# ions
seg <- fread('segmentation.csv',header=T)
anno <- fread('isletannoccs.csv')
ioncluster <- fread('ioncluster.csv')
library(pmd)
data("keggrall")
hfpmd <- as.numeric(names(table(keggrall$pmd)[table(keggrall$pmd)>mean(table(keggrall$pmd))]))
df <- getpmddf(mz,group = ioncluster$class,pmd=hfpmd,digits = 3)

subdf <- df[df$net=='local',]
subdf2 <- df[df$net!='local',]
library(igraph)
library(ggraph)
library(tidygraph)
net <- graph_from_data_frame(df)
graph <- as_tbl_graph(net)
ggraph(graph, layout = 'fr') +
   geom_edge_link(aes(color = net))  + theme_void()

net <- graph_from_data_frame(subdf)
graph <- as_tbl_graph(net)
ggraph(graph, layout = 'fr') + geom_edge_link(aes(color = diff2)) +theme_void()

net <- graph_from_data_frame(subdf2)
graph <- as_tbl_graph(net)
ggraph(graph, layout = 'fr') + geom_edge_link(aes(color = diff2)) +theme_void()

df$anno1 <- anno$name[match(df$ms1,anno$mz)]
df$anno2 <- anno$name[match(df$ms2,anno$mz)]

dfanno <- df[complete.cases(df),]

net <- graph_from_data_frame(dfanno)
graph <- as_tbl_graph(net)
ggraph(graph, layout = 'fr') + geom_edge_link(aes(color = net)) +theme_void()

fwrite(dfanno,'annonet.csv')
```

### MSInet Shiny application

Please run the following chunk to get the network csv file.

```{r}
library(pmd)
library(data.table)
dt <- fread("ticmzccs.csv",header = T)
dt_values <- dt[, -1, with = FALSE]

# m/z and im
mz <- sapply(strsplit(colnames(dt)[-1],'\\_'),function(x) round(as.numeric(x[1]),4))
im <- sapply(strsplit(colnames(dt)[-1],'\\_'),function(x) as.numeric(x[2]))

# ions
ioncluster <- fread('ioncluster.csv')
library(pmd)
data("keggrall")
hfpmd <- as.numeric(names(table(keggrall$pmd)[table(keggrall$pmd)>mean(table(keggrall$pmd))]))
df <- rmwf::getpmddf2(dt,group = ioncluster$class,pmd=hfpmd,digits = 3)
fwrite(df,'msinet.csv')
```

Please run the following chunk to get figures for ions.

```{r}
dir.create('fig')
ions <- unique(c(df$from,df$to))
mz <- sapply(strsplit(colnames(dt_values),'\\_'),function(x) round(as.numeric(x[1]),4))
im <- sapply(strsplit(colnames(dt_values),'\\_'),function(x) as.numeric(x[2]))
name <- paste0(mz,'_',round(im))
dt_values <- as.data.frame(dt_values)
sub <- dt_values[,match(ions,name)]
colnames(sub) <- ions
x <- sapply(strsplit(dt$location,'\\_'),function(x) as.numeric(x[1]))
y <- sapply(strsplit(dt$location,'\\_'),function(x) as.numeric(x[2]))
width=max(x)-min(x)+1
height=max(y)-min(y)+1
for(i in 1:ncol(sub)){
  dfx <- sub[,i]
  norm <- (dfx - min(dfx)) / (max(dfx) - min(dfx))
  library(RColorBrewer)
  color_palette <- colorRamp(c("skyblue", "red"))
  color_sequence <- rgb(color_palette(norm)/255,alpha=1)
  png(paste0('fig/',colnames(sub)[i],'.png'),width = width, height = height)
  plot.new()
  par(mar=c(0,0,0,0))
  plot.window(xlim = c(0,width), ylim = c(0,height), xaxs = "i", yaxs = "i", asp = NA)
  points(x-min(x)+1, y-min(y)+1, pch = 16, col = color_sequence,cex=0.3)
  dev.off()
}
```

You can start the shiny app by the following code:

```{r}
rmwf::runmsinet()
```

Then you could update network file (msinet.csv), annotation file (annoccs.csv) and images to generate network visualization for biological people.

```{r}
sessionInfo()
```
