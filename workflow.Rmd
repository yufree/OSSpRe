---
title: "MSI"
author: "Miao Yu"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    df_print: paged
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,eval = FALSE)
```

```{r}
# load function for workflow
source('helper.r')
```

# Raw data

## Reference peaks

Peaks from all pixels will be added together as one super pixel for reference peak picking.

```{r}
# set the path to the .d folder
path = 'PATH_TO_RAW.d'
# set the dll/so file
libpath = './'
# set the output file name
outref = 'refpeak.csv'
# set the coord output file name
outcoord = 'coord.csv'
# accept Bruker's lisence
accept_Bruker_EULA_and_on_Windows_or_Linux = TRUE
# set the pixel batch size to generate super pixel
batch_size <- 100000
# set pixel range
xrange <- c(3400,3900)
yrange <- c(1050,1600)

# This function processes raw mass spectrometry data to generate a reference peak list.
# - path: Path to the raw data (e.g., .d folder).
# - accept_Bruker_EULA_and_on_Windows_or_Linux: Set to TRUE to accept the Bruker EULA.
# - libpath: Path to the Bruker library files.
# - batch_size: The number of frames to process in each batch.
# - outref: The output file for the reference peaks.
# - outcoord: The output file for the coordinates.
# - xrange: The x-range of the region of interest.
# - yrange: The y-range of the region of interest.
getrefpeak(path = path,accept_Bruker_EULA_and_on_Windows_or_Linux = accept_Bruker_EULA_and_on_Windows_or_Linux, batch_size = batch_size, outref = outref, outcoord = outcoord, xrange = xrange,yrange = yrange)
```

## Reference peak picking

This part will be used to find reference peaks across the sample.

### Reference peak picking

Set the parameters for peak picking and perform peak picking on super pixels. The default setting will keep all the local max peaks found in the super pixel. However, most of the peaks with smaller intensity will not be retained in the following filtering analysis and more peaks will use more computational resources for peak picking. In this case, intensity cutoff could be carefully set depending on the sensitivity of the instrument and the mean/median value of all the peaks' intensity could be the first choice.

```{r}
library(data.table)
dtx <- fread('refpeak.csv')
mz_ppm <- 20
ccs_tolerance <- 0.03
snr <- 3
mz_bins <- 1000
ccs_bins <- 50

# This function performs 2D peak picking.
# - dtx$mz: The m/z values.
# - dtx$ccs: The CCS values.
# - dtx$intensity: The intensity values.
# - mz_ppm: The m/z tolerance in ppm.
# - ccs_tolerance: The CCS tolerance.
# - snr: The signal-to-noise ratio cutoff.
# - mz_bins: The number of m/z bins.
# - ccs_bins: The number of CCS bins.
result <- find_2d_peaks(dtx$mz,dtx$ccs,dtx$intensity,mz_ppm,ccs_tolerance,snr,mz_bins,ccs_bins)
fwrite(result,'ref2d.csv')
# retain peaks larger than mean value of all reference peaks
# sub <- result[result$intensity>mean(result$intensity),]
# fwrite(sub,'ref2d.csv')
```

# Quantitative Peaks List

This part will extract peak intensity on all pixels according to extracted reference peaks from super pixel.

```{r}
# load the reference peaks
refpath = 'ref2d.csv'
# change to libtimsdata.dll for windows
lib_path <- paste0(libpath,"libtimsdata.so")
# load the raw data
path = 'PATH_TO_RAW.d'
# set normalization method tic or rms
method = 'tic'
# set zero_proportion to remove the peaks with zero_proportion larger than 95%
zero_proportion_cutoff = 0.95
# set the coord file path
coordpath = 'coord.csv'
# set the output file name
normpath = 'ticmzccs.csv'
# set pixel range
xrange <- c(3400,3900)
yrange <- c(1050,1600)

# This function generates a quantitative peak list.
# - refpath: Path to the reference peaks file.
# - lib_path: Path to the Bruker library files.
# - path: Path to the raw data.
# - method: The normalization method ('tic' or 'rms').
# - zero_proportion_cutoff: The cutoff for removing peaks with a high proportion of zeros.
# - coordpath: Path to the coordinates file.
# - normpath: The output file for the normalized peak list.
# - xrange: The x-range of the region of interest.
# - yrange: The y-range of the region of interest.
getqlist(refpath = refpath,lib_path = lib_path, path = path, method = method, zero_proportion_cutoff = zero_proportion_cutoff, coordpath = coordpath, normpath = normpath, xrange = xrange, yrange = yrange)
```

# Qualitative Peaks List

Qualitative analysis is performed with public available data for MS1-CCS database.

## Lipid annotation

```{r}
# load database
database = 'lipidall.csv'
mode = 'pos'
peakpath = 'ticmzccs.csv'
annofile = 'annoccs.csv'

# This function annotates peaks against a lipid database.
# - database: Path to the lipid database.
# - mode: The ionization mode ('pos' or 'neg').
# - peakpath: Path to the peak list file.
# - annofile: The output file for the annotations.
getanno(database = database,mode = mode, peakpath = peakpath, annofile = annofile)
```

## Metabolites annotation

```{r}
# load database
database = 'metaall.csv'
mode = 'pos'
peakpath = 'ticmzccs.csv'
annofile = 'metaannoccs.csv'

# This function annotates peaks against a metabolite database.
# - database: Path to the metabolite database.
# - mode: The ionization mode ('pos' or 'neg').
# - peakpath: Path to the peak list file.
# - annofile: The output file for the annotations.
getanno(database = database,mode = mode, peakpath = peakpath, annofile = annofile)
```

## mzccsanno Shiny application

You could also use a Shiny application to make annotation with GUI.

```{r}
rmwf::runmzccsanno()
```

# Exploratory Analysis

## Data Summary

This section provides a verbose summary of the processed peak data file.

```{r}
# This function reads the peak file and prints a summary of its contents,
# including the number of pixels, number of features, and the ranges for
# m/z, ion mobility (CCS), and spatial coordinates.
# - "ticmzccs.csv": The path to the input peak file.
verbose_summary("ticmzccs.csv")
```

## Peak statistics

This part will show the distribution of peak numbers.

```{r}
# This function generates and displays plots for peak statistics.
# - "ticmzccs.csv": The input peak file.
plot_peak_stats("ticmzccs.csv")
```

## Visualization

Save selected or all ion images for all reference peaks.

```{r}
# Define a vector of m/z values for which to generate ion images.
mzdemo <- c(703.5732,725.5543,739.4657,760.5806,788.6030,798.5397,826.5585)

# This function saves ion images for the specified m/z values.
# - "ticmzccs.csv": The input peak file.
# - mzdemo: A vector of m/z values.
save_ion_images("ticmzccs.csv", mzdemo)
```

## Segmentation

Segmentation can find region of interests in MSI data.

### PCA segmentation

This part will use PCA to perform segmentation.

```{r}
# This function performs PCA segmentation on the peak data.
# - "ticmzccs.csv": The input peak file.
# - "segmentation.csv": The output file for the segmentation results.
perform_pca_segmentation("ticmzccs.csv", "segmentation.csv")
```

### UMAP segmentation

This part will use UMAP to perform segmentation.

```{r}
# This function performs UMAP segmentation on the peak data.
# - "ticmzccs.csv": The input peak file.
# - "segmentation.csv": The output file for the segmentation results.
perform_umap_segmentation("ticmzccs.csv", "segmentation.csv")
```

## Ion cluster

This part will use cosin/correlation similarity to find ion clusters with similar spatial distribution.

```{r}
# This function clusters ions based on their spatial distribution.
# - "ticmzccs.csv": The input peak file.
# - "segmentation.csv": The segmentation file.
# - "ioncluster.csv": The output file for the ion clusters.
cluster_ions("ticmzccs.csv", "segmentation.csv", "ioncluster.csv")
```

###  ROI specific Ion cluster for ions in certain segmentation

```{r}
# This function clusters ions within a specific region of interest (ROI).
# - "ticmzccs.csv": The input peak file.
# - "segmentation.csv": The segmentation file.
# - "roi_ion_cluster.csv": The output file for the ROI ion clusters.
cluster_roi_ions("ticmzccs.csv", "segmentation.csv", "roi_ion_cluster.csv")
```

## Reactomics analysis

This part will extract PMDs for reaction level check.

```{r}
# This function performs reactomics analysis.
# - "ticmzccs.csv": The input peak file.
# - "segmentation.csv": The segmentation file.
# - "isletcheckall.csv": The file containing islet information.
# - "reactomics.csv": The output file for the reactomics analysis.
perform_reactomics_analysis("ticmzccs.csv", "segmentation.csv", "isletcheckall.csv", "reactomics.csv")
```

## Molecular Network

```{r}
# This function generates a molecular network.
# - "ticmzccs.csv": The input peak file.
# - "ioncluster.csv": The ion cluster file.
# - "annoccs.csv": The annotation file.
# - "molecular_network.csv": The output file for the molecular network.
generate_molecular_network("ticmzccs.csv", "ioncluster.csv", "annoccs.csv", "molecular_network.csv")
```

### MSInet Shiny application

Please run the following chunk to get the network csv file.

```{r}
library(pmd)
library(data.table)
dt <- fread("ticmzccs.csv",header = T)

# m/z and im
mz <- sapply(strsplit(colnames(dt)[-1],'_'),function(x) round(as.numeric(x[1]),4))
im <- sapply(strsplit(colnames(dt)[-1],'_'),function(x) as.numeric(x[2]))

# ions
ioncluster <- fread('ioncluster.csv')
library(pmd)
data("keggrall")
hfpmd <- as.numeric(names(table(keggrall$pmd)[table(keggrall$pmd)>mean(table(keggrall$pmd))]))
df <- rmwf::getpmddf2(dt,group = ioncluster$class,pmd=hfpmd,digits = 3)
fwrite(df,'msinet.csv')
```

Please run the following chunk to get figures for ions.

```{r}
dir.create('fig')
ions <- unique(c(df$from,df$to))
mz <- sapply(strsplit(colnames(dt_values),'_'),function(x) round(as.numeric(x[1]),4))
im <- sapply(strsplit(colnames(dt_values),'_'),function(x) as.numeric(x[2]))
name <- paste0(mz,'_',round(im))
dt_values <- as.data.frame(dt_values)
sub <- dt_values[,match(ions,name)]
colnames(sub) <- ions
x <- sapply(strsplit(dt$location,'_'),function(x) as.numeric(x[1]))
y <- sapply(strsplit(dt$location,'_'),function(x) as.numeric(x[2]))
width=max(x)-min(x)+1
height=max(y)-min(y)+1
for(i in 1:ncol(sub)){
  dfx <- sub[,i]
  norm <- (dfx - min(dfx)) / (max(dfx) - min(dfx))
  library(RColorBrewer)
  color_palette <- colorRamp(c("skyblue", "red"))
  color_sequence <- rgb(color_palette(norm)/255,alpha=1)
  png(paste0('fig/',colnames(sub)[i],'.png'),width = width, height = height)
  plot.new()
  par(mar=c(0,0,0,0))
  plot.window(xlim = c(0,width), ylim = c(0,height), xaxs = "i", yaxs = "i", asp = NA)
  points(x-min(x)+1, y-min(y)+1, pch = 16, col = color_sequence,cex=0.3)
  dev.off()
}
```

You can start the shiny app by the following code:

```{r}
rmwf::runmsinet()
```

Then you could update network file (msinet.csv), annotation file (annoccs.csv) and images to generate network visualization for biological people.

```{r}
sessionInfo()
```